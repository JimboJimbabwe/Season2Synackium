#!/usr/bin/env python3
import os
import json
import argparse
import threading
from pathlib import Path
import tkinter as tk
from tkinter import ttk, scrolledtext
import customtkinter as ctk
from PIL import Image, ImageTk
import math

# Set appearance mode and default color theme
ctk.set_appearance_mode("System")  # Modes: "System" (standard), "Dark", "Light"
ctk.set_default_color_theme("blue")  # Themes: "blue" (standard), "green", "dark-blue"

# Base directory where all testing directories are located
BASE_DIR = None

def sanitize_directory_name(name):
    """
    Sanitize directory name to be compatible with display purposes.
    
    Args:
        name (str): The directory name to sanitize
    
    Returns:
        str: Sanitized directory name for display
    """
    # Use underscore as a replacement for forward/back slashes in display
    return name.replace('_', ' ')

def get_targets():
    """
    Get all target directories (subfolders) in the base directory.
    
    Returns:
        list: List of target directory names
    """
    targets = []
    for item in Path(BASE_DIR).iterdir():
        if item.is_dir() and not item.name.startswith('.'):
            targets.append(item.name)
    return sorted(targets)

def get_categories(target, section):
    """
    Get all categories in a target's section (Auth or raw).
    
    Args:
        target (str): Target directory name
        section (str): Section name (Auth or raw)
        
    Returns:
        list: List of category directory names
    """
    categories = []
    section_path = Path(BASE_DIR) / target / section
    
    if section_path.exists():
        for item in section_path.iterdir():
            if item.is_dir():
                categories.append(item.name)
    
    return sorted(categories)

def get_test_types(target, section, category):
    """
    Get all test types in a category.
    
    Args:
        target (str): Target directory name
        section (str): Section name (Auth or raw)
        category (str): Category directory name
        
    Returns:
        list: List of test type directory names
    """
    test_types = []
    test_path = Path(BASE_DIR) / target / section / category
    
    if test_path.exists():
        for item in test_path.iterdir():
            if item.is_dir():
                test_types.append(item.name)
    
    return sorted(test_types)

def get_results_files(target, section, category, test_type):
    """
    Get all JSON files in a test type's results directory.
    
    Args:
        target (str): Target directory name
        section (str): Section name (Auth or raw)
        category (str): Category directory name
        test_type (str): Test type directory name
        
    Returns:
        list: List of JSON file names
    """
    results_path = Path(BASE_DIR) / target / section / category / test_type / "results"
    json_files = []
    
    if results_path.exists():
        for item in results_path.glob("*.json"):
            if item.is_file():
                json_files.append(item.name)
    
    return sorted(json_files)

def load_json_data(target, section, category, test_type, filename):
    """
    Load JSON data from a results file.
    
    Args:
        target (str): Target directory name
        section (str): Section name (Auth or raw)
        category (str): Category directory name
        test_type (str): Test type directory name
        filename (str): JSON file name
        
    Returns:
        dict: JSON data
    """
    file_path = Path(BASE_DIR) / target / section / category / test_type / "results" / filename
    
    if file_path.exists():
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            return {"error": f"Failed to load JSON: {str(e)}"}
    
    return {"error": "File not found"}

# Placeholder functions for different test result processors
def process_xpath_results(data):
    """
    Process XPATH test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "title": data.get("title", ""),
        "description": data.get("description", ""),
        "vulnerable_parameters": data.get("vulnerable_parameters", {}),
        "request_count": data.get("request_count", 0),
        "requests_with_vulnerable_params": data.get("requests_with_vulnerable_params", 0),
        "total_vulnerable_params": data.get("total_vulnerable_params", 0),
        "high_risk_count": data.get("high_risk_count", 0),
        "medium_risk_count": data.get("medium_risk_count", 0),
        "low_risk_count": data.get("low_risk_count", 0),
        "requests": data.get("requests", [])
    }
    
    return processed

def process_css_results(data):
    """
    Process CSS injection test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "title": data.get("title", ""),
        "description": data.get("description", ""),
        "vulnerable_parameters": data.get("vulnerable_parameters", {}),
        "request_count": data.get("request_count", 0),
        "requests_with_vulnerable_params": data.get("requests_with_vulnerable_params", 0),
        "total_vulnerable_params": data.get("total_vulnerable_params", 0),
        "high_risk_count": data.get("high_risk_count", 0),
        "medium_risk_count": data.get("medium_risk_count", 0),
        "low_risk_count": data.get("low_risk_count", 0),
        "requests": data.get("requests", [])
    }
    
    return processed

def process_url_parameters(data):
    """
    Process URL parameters test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "urls": []
    }
    
    # Process each URL
    if "urls" in data:
        for idx, url_data in enumerate(data["urls"]):
            url_info = {
                "index": idx,
                "url": url_data.get("url", "Unknown"),
                "method": url_data.get("method", "GET"),
                "parameter_count": len(url_data.get("parameters", [])),
                "parameters": url_data.get("parameters", [])
            }
            processed["urls"].append(url_info)
    
    return processed

def process_sql_results(data):
    """
    Process SQL injection test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "title": data.get("title", ""),
        "description": data.get("description", ""),
        "vulnerable_parameters": data.get("vulnerable_parameters", {}),
        "request_count": data.get("request_count", 0),
        "requests_with_vulnerable_params": data.get("requests_with_vulnerable_params", 0),
        "total_vulnerable_params": data.get("total_vulnerable_params", 0),
        "high_risk_count": data.get("high_risk_count", 0),
        "medium_risk_count": data.get("medium_risk_count", 0),
        "low_risk_count": data.get("low_risk_count", 0),
        "requests": data.get("requests", [])
    }
    
    return processed

def process_sensitive_info(data):
    """
    Process sensitive information test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "urls": []
    }
    
    # Process each URL with findings
    if "urls" in data:
        for url_data in data["urls"]:
            url_info = {
                "url": url_data.get("url", "Unknown"),
                "findings": url_data.get("findings", [])
            }
            processed["urls"].append(url_info)
    
    return processed

def process_path_finder(data):
    """
    Process path finder test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "url": data.get("url", "Unknown"),
        "base_url": data.get("base_url", ""),
        "paths": data.get("paths", []),
        "directories": data.get("directories", []),
        "findings": data.get("findings", []),
        "stats": data.get("stats", {}),
        "source_urls": data.get("source_urls", []),
        "aggregate_source_count": data.get("aggregate_source_count", 0)
    }
    
    # Process potentially sensitive files
    if "files" in data and "potentially_sensitive" in data["files"]:
        processed["sensitive_files"] = data["files"]["potentially_sensitive"]
    else:
        processed["sensitive_files"] = []
    
    return processed

def process_json_results(data):
    """
    Process JSON test results.
    
    Args:
        data (dict): JSON data
        
    Returns:
        dict: Processed data for rendering
    """
    processed = {
        "debug_info": []
    }
    
    # Process each debug_info entry
    if "debug_info" in data:
        for debug_entry in data["debug_info"]:
            entry_info = {
                "index": debug_entry.get("index", "N/A"),
                "url": debug_entry.get("url", "Unknown"),
                "body_length": debug_entry.get("body_length", 0)
            }
            processed["debug_info"].append(entry_info)
    
    # Also include summary data if available
    processed["request_count"] = data.get("request_count", 0)
    processed["json_request_count"] = data.get("json_request_count", 0)
    processed["total_parameters"] = data.get("total_parameters", 0)
    processed["title"] = data.get("title", "")
    processed["description"] = data.get("description", "")
    
    return processed

# Map test types to their processor functions
TEST_PROCESSORS = {
    "XPath_XQuery Injection": process_xpath_results,
    "URL Parameters": process_url_parameters,
    "SQL Injection": process_sql_results,
    "Sensitive Information Leak to Third-Parties": process_sensitive_info,
    "Sensitive Directory_File Contents Disclosed": process_sensitive_info,
    "Path Traversal": process_path_finder,
    "JSON Injection": process_json_results,
    "CSS Injection": process_css_results,
    # Default fallback processor
    "default": lambda data: data
}

def get_processor_for_test(test_type):
    """
    Get the appropriate processor function for a test type.
    
    Args:
        test_type (str): Test type name
        
    Returns:
        function: Processor function
    """
    return TEST_PROCESSORS.get(test_type, TEST_PROCESSORS["default"])

class NavigatorApp:
    def __init__(self, root, base_dir):
        self.root = root
        self.base_dir = base_dir
        global BASE_DIR
        BASE_DIR = base_dir
        
        self.root.title("Security Testing Directory Navigator")
        self.root.geometry("1280x768")
        
        # State variables
        self.current_target = None
        self.current_section = None
        self.current_category = None
        self.current_test_type = None
        self.current_result_file = None
        self.raw_data = None
        self.processed_data = None
        
        # Create main frame
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Split the main frame into sidebar and content
        self.create_sidebar()
        self.create_content_area()
        
        # Initialize navigation state
        self.initialize_navigation()
        
    def create_sidebar(self):
        # Create a frame for the sidebar
        self.sidebar_frame = ctk.CTkFrame(self.main_frame, width=250)
        self.sidebar_frame.pack(side="left", fill="y", padx=5, pady=5)
        
        # Create label and treeview for navigation
        sidebar_label = ctk.CTkLabel(self.sidebar_frame, text="Navigation", font=("Arial", 14, "bold"))
        sidebar_label.pack(pady=10)
        
        # Create a frame for the treeview
        tree_frame = ctk.CTkFrame(self.sidebar_frame)
        tree_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Create Treeview for navigation
        self.tree = ttk.Treeview(tree_frame, selectmode="browse")
        self.tree.pack(fill="both", expand=True)
        
        # Configure Treeview style for better visibility in dark mode
        style = ttk.Style()
        style.configure("Treeview", background="#2b2b2b", foreground="white", fieldbackground="#2b2b2b")
        style.configure("Treeview.Heading", background="#2b2b2b", foreground="white")
        style.map('Treeview', background=[('selected', '#347ab3')])
        
        # Add a scrollbar to the treeview
        tree_scrollbar = ctk.CTkScrollbar(tree_frame, command=self.tree.yview)
        tree_scrollbar.pack(side="right", fill="y")
        self.tree.configure(yscrollcommand=tree_scrollbar.set)
        
        # Bind selection event
        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)
    
    def create_content_area(self):
        # Create a frame for the content area
        self.content_frame = ctk.CTkFrame(self.main_frame)
        self.content_frame.pack(side="right", fill="both", expand=True, padx=5, pady=5)
        
        # Create breadcrumb frame
        self.breadcrumb_frame = ctk.CTkFrame(self.content_frame)
        self.breadcrumb_frame.pack(fill="x", padx=10, pady=10)
        
        self.breadcrumb_label = ctk.CTkLabel(self.breadcrumb_frame, text="Home", font=("Arial", 12))
        self.breadcrumb_label.pack(side="left", padx=5)
        
        # Create a separator
        separator = ttk.Separator(self.content_frame, orient="horizontal")
        separator.pack(fill="x", padx=10, pady=5)
        
        # Create result area with tabs
        self.tab_view = ctk.CTkTabview(self.content_frame)
        self.tab_view.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create tabs
        self.processed_tab = self.tab_view.add("Processed View")
        self.raw_tab = self.tab_view.add("Raw JSON")
        
        # Create frames for each tab
        self.processed_frame = ctk.CTkFrame(self.processed_tab)
        self.processed_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        self.raw_frame = ctk.CTkFrame(self.raw_tab)
        self.raw_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Add text area for raw JSON
        self.raw_text = scrolledtext.ScrolledText(self.raw_frame, wrap=tk.WORD, bg="#2b2b2b", fg="white", font=("Courier", 10))
        self.raw_text.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Initialize processed view with scrollable frame
        self.processed_scroll = ctk.CTkScrollableFrame(self.processed_frame)
        self.processed_scroll.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Welcome message
        welcome_label = ctk.CTkLabel(self.processed_scroll, text="Select a target to get started", font=("Arial", 14, "bold"))
        welcome_label.pack(pady=20)
    
    def initialize_navigation(self):
        # Clear the treeview
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        # Add targets
        targets = get_targets()
        for target in targets:
            target_id = self.tree.insert("", "end", text=target, values=("target", target))
            
            # Add sections
            for section in ["Auth", "raw"]:
                section_id = self.tree.insert(target_id, "end", text=section, values=("section", section))
    
    def on_tree_select(self, event):
        # Get selected item
        selected_item = self.tree.focus()
        if not selected_item:
            return
        
        item_type, item_value = self.tree.item(selected_item, "values")
        parent_item = self.tree.parent(selected_item)
        
        if item_type == "target":
            self.current_target = item_value
            self.current_section = None
            self.current_category = None
            self.current_test_type = None
            self.current_result_file = None
            
            # Update breadcrumb
            self.update_breadcrumb()
            
            # Clear the content area
            self.clear_content()
            
            # Display message
            label = ctk.CTkLabel(self.processed_scroll, text=f"Selected Target: {self.current_target}\nPlease select a section (Auth or raw)", font=("Arial", 14))
            label.pack(pady=20)
            
        elif item_type == "section":
            self.current_section = item_value
            self.current_category = None
            self.current_test_type = None
            self.current_result_file = None
            
            # Get target from parent
            parent_type, parent_value = self.tree.item(parent_item, "values")
            if parent_type == "target":
                self.current_target = parent_value
            
            # Update breadcrumb
            self.update_breadcrumb()
            
            # Load categories
            self.load_categories()
            
        elif item_type == "category":
            self.current_category = item_value
            self.current_test_type = None
            self.current_result_file = None
            
            # Get section from parent
            parent_type, parent_value = self.tree.item(parent_item, "values")
            if parent_type == "section":
                self.current_section = parent_value
                
                # Get target from parent's parent
                grandparent = self.tree.parent(parent_item)
                grandparent_type, grandparent_value = self.tree.item(grandparent, "values")
                if grandparent_type == "target":
                    self.current_target = grandparent_value
            
            # Update breadcrumb
            self.update_breadcrumb()
            
            # Load test types
            self.load_test_types()
            
        elif item_type == "test_type":
            self.current_test_type = item_value
            self.current_result_file = None
            
            # Get category from parent
            parent_type, parent_value = self.tree.item(parent_item, "values")
            if parent_type == "category":
                self.current_category = parent_value
                
                # Get section from parent's parent
                grandparent = self.tree.parent(parent_item)
                grandparent_type, grandparent_value = self.tree.item(grandparent, "values")
                if grandparent_type == "section":
                    self.current_section = grandparent_value
                    
                    # Get target from parent's parent's parent
                    great_grandparent = self.tree.parent(grandparent)
                    great_grandparent_type, great_grandparent_value = self.tree.item(great_grandparent, "values")
                    if great_grandparent_type == "target":
                        self.current_target = great_grandparent_value
            
            # Update breadcrumb
            self.update_breadcrumb()
            
            # Load result files
            self.load_result_files()
            
        elif item_type == "result_file":
            self.current_result_file = item_value
            
            # Get test_type from parent
            parent_type, parent_value = self.tree.item(parent_item, "values")
            if parent_type == "test_type":
                self.current_test_type = parent_value
                
                # Get category from parent's parent
                grandparent = self.tree.parent(parent_item)
                grandparent_type, grandparent_value = self.tree.item(grandparent, "values")
                if grandparent_type == "category":
                    self.current_category = grandparent_value
                    
                    # Get section from parent's parent's parent
                    great_grandparent = self.tree.parent(grandparent)
                    great_grandparent_type, great_grandparent_value = self.tree.item(great_grandparent, "values")
                    if great_grandparent_type == "section":
                        self.current_section = great_grandparent_value
                        
                        # Get target from parent's parent's parent's parent
                        great_great_grandparent = self.tree.parent(great_grandparent)
                        great_great_grandparent_type, great_great_grandparent_value = self.tree.item(great_great_grandparent, "values")
                        if great_great_grandparent_type == "target":
                            self.current_target = great_great_grandparent_value
            
            # Update breadcrumb
            self.update_breadcrumb()
            
            # Load and display result data
            self.load_result_data()
    
    def update_breadcrumb(self):
        breadcrumb_text = "Home"
        
        if self.current_target:
            breadcrumb_text += f" > {self.current_target}"
            
        if self.current_section:
            breadcrumb_text += f" > {self.current_section}"
            
        if self.current_category:
            breadcrumb_text += f" > {sanitize_directory_name(self.current_category)}"
            
        if self.current_test_type:
            breadcrumb_text += f" > {sanitize_directory_name(self.current_test_type)}"
            
        if self.current_result_file:
            breadcrumb_text += f" > {self.current_result_file}"
        
        self.breadcrumb_label.configure(text=breadcrumb_text)
    
    def clear_content(self):
        # Clear processed view
        for widget in self.processed_scroll.winfo_children():
            widget.destroy()
        
        # Clear raw JSON view
        self.raw_text.delete(1.0, tk.END)
    
    def load_categories(self):
        # Clear any existing children
        for child in self.tree.get_children(self.tree.focus()):
            self.tree.delete(child)
            
        # Get categories
        categories = get_categories(self.current_target, self.current_section)
        
        # Add categories to tree
        for category in categories:
            self.tree.insert(self.tree.focus(), "end", text=sanitize_directory_name(category), values=("category", category))
        
        # Update content area
        self.clear_content()
        
        # Display message
        label = ctk.CTkLabel(self.processed_scroll, text=f"Selected Section: {self.current_section}\nPlease select a category", font=("Arial", 14))
        label.pack(pady=20)
        
        # Create a listbox for categories
        category_frame = ctk.CTkFrame(self.processed_scroll)
        category_frame.pack(fill="x", pady=10, padx=10)
        
        category_label = ctk.CTkLabel(category_frame, text="Available Categories:", font=("Arial", 12, "bold"))
        category_label.pack(anchor="w", pady=5)
        
        for category in categories:
            category_button = ctk.CTkButton(
                category_frame, 
                text=sanitize_directory_name(category), 
                command=lambda cat=category: self.select_category_from_button(cat)
            )
            category_button.pack(fill="x", pady=2)
    
    def select_category_from_button(self, category):
        # Find the category item in the tree
        parent_item = self.tree.focus()
        for child in self.tree.get_children(parent_item):
            if self.tree.item(child, "values")[1] == category:
                self.tree.focus(child)
                self.tree.selection_set(child)
                self.on_tree_select(None)
                break
    
    def load_test_types(self):
        # Clear any existing children
        for child in self.tree.get_children(self.tree.focus()):
            self.tree.delete(child)
            
        # Get test types
        test_types = get_test_types(self.current_target, self.current_section, self.current_category)
        
        # Add test types to tree
        for test_type in test_types:
            self.tree.insert(self.tree.focus(), "end", text=sanitize_directory_name(test_type), values=("test_type", test_type))
        
        # Update content area
        self.clear_content()
        
        # Display message
        label = ctk.CTkLabel(self.processed_scroll, text=f"Selected Category: {sanitize_directory_name(self.current_category)}\nPlease select a test type", font=("Arial", 14))
        label.pack(pady=20)
        
        # Create a frame for test types
        test_frame = ctk.CTkFrame(self.processed_scroll)
        test_frame.pack(fill="x", pady=10, padx=10)
        
        test_label = ctk.CTkLabel(test_frame, text="Available Test Types:", font=("Arial", 12, "bold"))
        test_label.pack(anchor="w", pady=5)
        
        for test_type in test_types:
            test_button = ctk.CTkButton(
                test_frame, 
                text=sanitize_directory_name(test_type), 
                command=lambda tt=test_type: self.select_test_type_from_button(tt)
            )
            test_button.pack(fill="x", pady=2)
    
    def select_test_type_from_button(self, test_type):
        # Find the test type item in the tree
        parent_item = self.tree.focus()
        for child in self.tree.get_children(parent_item):
            if self.tree.item(child, "values")[1] == test_type:
                self.tree.focus(child)
                self.tree.selection_set(child)
                self.on_tree_select(None)
                break
    
    def load_result_files(self):
        # Clear any existing children
        for child in self.tree.get_children(self.tree.focus()):
            self.tree.delete(child)
            
        # Get result files
        result_files = get_results_files(self.current_target, self.current_section, self.current_category, self.current_test_type)
        
        # Add result files to tree
        for result_file in result_files:
            self.tree.insert(self.tree.focus(), "end", text=result_file, values=("result_file", result_file))
        
        # Update content area
        self.clear_content()
        
        # Display message
        label = ctk.CTkLabel(self.processed_scroll, text=f"Selected Test Type: {sanitize_directory_name(self.current_test_type)}\nPlease select a result file", font=("Arial", 14))
        label.pack(pady=20)
        
        # Create a frame for result files
        result_frame = ctk.CTkFrame(self.processed_scroll)
        result_frame.pack(fill="x", pady=10, padx=10)
        
        if not result_files:
            no_files_label = ctk.CTkLabel(result_frame, text="No result files found", font=("Arial", 12))
            no_files_label.pack(pady=10)
        else:
            files_label = ctk.CTkLabel(result_frame, text="Available Result Files:", font=("Arial", 12, "bold"))
            files_label.pack(anchor="w", pady=5)
            
            for result_file in result_files:
                file_button = ctk.CTkButton(
                    result_frame, 
                    text=result_file, 
                    command=lambda rf=result_file: self.select_result_file_from_button(rf)
                )
                file_button.pack(fill="x", pady=2)
    
    def select_result_file_from_button(self, result_file):
        # Find the result file item in the tree
        parent_item = self.tree.focus()
        for child in self.tree.get_children(parent_item):
            if self.tree.item(child, "values")[1] == result_file:
                self.tree.focus(child)
                self.tree.selection_set(child)
                self.on_tree_select(None)
                break
    
    def load_result_data(self):
        # Load the JSON data
        self.clear_content()
        
        # Display loading message
        loading_label = ctk.CTkLabel(self.processed_scroll, text="Loading result data...", font=("Arial", 14))
        loading_label.pack(pady=20)
        
        # Use threading to prevent UI freeze during loading
        threading.Thread(target=self.load_and_process_data).start()
    
    def load_and_process_data(self):
        try:
            # Load the JSON data
            self.raw_data = load_json_data(
                self.current_target, 
                self.current_section, 
                self.current_category, 
                self.current_test_type, 
                self.current_result_file
            )
            
            # Process the data
            processor = get_processor_for_test(self.current_test_type)
            self.processed_data = processor(self.raw_data)
            
            # Update UI on the main thread
            self.root.after(0, self.update_result_display)
        except Exception as e:
            # Update UI on the main thread
            self.root.after(0, lambda: self.display_error(str(e)))
    
    def display_error(self, error_message):
        self.clear_content()
        error_label = ctk.CTkLabel(self.processed_scroll, text=f"Error: {error_message}", font=("Arial", 14), text_color="red")
        error_label.pack(pady=20)
    
    
    def update_result_display(self):
        # Clear the content
        self.clear_content()
        
        # Update raw JSON view
        self.raw_text.insert(tk.END, json.dumps(self.raw_data, indent=2))
        
        # If error in raw data
        if "error" in self.raw_data:
            error_label = ctk.CTkLabel(self.processed_scroll, text=f"Error: {self.raw_data['error']}", font=("Arial", 14), text_color="red")
            error_label.pack(pady=20)
            return
        
        # Update processed view based on test type
        if self.current_test_type.replace('_', ' ').lower().find("xpath") >= 0 or self.current_test_type.replace('_', ' ').lower().find("xquery") >= 0:
            self.render_xpath_results()
        elif self.current_test_type == "URL Parameters":
            self.render_url_parameters_results()
        elif self.current_test_type == "SQL Injection":
            self.render_sql_results()
        elif self.current_test_type.replace('_', ' ').lower().find("sensitive") >= 0:
            self.render_sensitive_info_results()
        elif self.current_test_type == "Path Traversal":
            self.render_path_finder_results()
        elif self.current_test_type == "JSON Injection":
            self.render_json_results()
        elif self.current_test_type == "CSS Injection":
            self.render_css_results()
        else:
            # Default renderer
            self.render_default_results()
    
    def render_xpath_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="XPath/XQuery Injection Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display title and description if available
        if self.processed_data.get("title") or self.processed_data.get("description"):
            info_frame = ctk.CTkFrame(self.processed_scroll)
            info_frame.pack(fill="x", pady=5, padx=10)
            
            if self.processed_data.get("title"):
                title_label = ctk.CTkLabel(info_frame, text=f"Title: {self.processed_data.get('title')}", 
                                         font=("Arial", 14, "bold"))
                title_label.pack(anchor="w", pady=5, padx=10)
            
            if self.processed_data.get("description"):
                desc_label = ctk.CTkLabel(info_frame, text=f"Description: {self.processed_data.get('description')}", 
                                        font=("Arial", 12))
                desc_label.pack(anchor="w", pady=5, padx=10)
        
        # Display statistics
        stats_frame = ctk.CTkFrame(self.processed_scroll)
        stats_frame.pack(fill="x", pady=5, padx=10)
        
        stats_label = ctk.CTkLabel(stats_frame, text="Statistics", font=("Arial", 14, "bold"))
        stats_label.pack(anchor="w", pady=5, padx=10)
        
        stats_grid = ctk.CTkFrame(stats_frame)
        stats_grid.pack(fill="x", pady=5, padx=10)
        
        # Create a grid for stats (2x3)
        req_count_label = ctk.CTkLabel(stats_grid, 
                                     text=f"Total Requests: {self.processed_data.get('request_count', 0)}", 
                                     font=("Arial", 12))
        req_count_label.grid(row=0, column=0, sticky="w", padx=10, pady=2)
        
        vuln_req_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Requests with Vulnerable Params: {self.processed_data.get('requests_with_vulnerable_params', 0)}", 
                                    font=("Arial", 12))
        vuln_req_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
        
        total_vuln_label = ctk.CTkLabel(stats_grid, 
                                      text=f"Total Vulnerable Params: {self.processed_data.get('total_vulnerable_params', 0)}", 
                                      font=("Arial", 12))
        total_vuln_label.grid(row=0, column=2, sticky="w", padx=10, pady=2)
        
        high_risk_label = ctk.CTkLabel(stats_grid, 
                                     text=f"High Risk: {self.processed_data.get('high_risk_count', 0)}", 
                                     font=("Arial", 12), text_color="#ff5555")
        high_risk_label.grid(row=1, column=0, sticky="w", padx=10, pady=2)
        
        medium_risk_label = ctk.CTkLabel(stats_grid, 
                                       text=f"Medium Risk: {self.processed_data.get('medium_risk_count', 0)}", 
                                       font=("Arial", 12), text_color="#ffaa55")
        medium_risk_label.grid(row=1, column=1, sticky="w", padx=10, pady=2)
        
        low_risk_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Low Risk: {self.processed_data.get('low_risk_count', 0)}", 
                                    font=("Arial", 12), text_color="#55aa55")
        low_risk_label.grid(row=1, column=2, sticky="w", padx=10, pady=2)
        
        # Check if there are any requests
        if not self.processed_data.get("requests") or len(self.processed_data["requests"]) == 0:
            if not self.processed_data.get("vulnerable_parameters") or len(self.processed_data["vulnerable_parameters"]) == 0:
                no_data_label = ctk.CTkLabel(self.processed_scroll, text="No vulnerable parameters found.", font=("Arial", 12))
                no_data_label.pack(pady=10)
                return
        
        # Create a frame for vulnerable parameters if any exist
        if self.processed_data.get("vulnerable_parameters") and len(self.processed_data["vulnerable_parameters"]) > 0:
            vuln_params_frame = ctk.CTkFrame(self.processed_scroll)
            vuln_params_frame.pack(fill="x", pady=10, padx=10)
            
            vuln_params_label = ctk.CTkLabel(vuln_params_frame, text="Vulnerable Parameters", font=("Arial", 14, "bold"))
            vuln_params_label.pack(anchor="w", pady=5, padx=10)
            
            # Create a scrollable frame for vulnerable parameters
            params_scroll = ctk.CTkScrollableFrame(vuln_params_frame, height=200)
            params_scroll.pack(fill="x", expand=True, pady=5, padx=10)
            
            # Display each vulnerable parameter
            for param_name, param_data in self.processed_data["vulnerable_parameters"].items():
                # Create a frame for this parameter
                param_frame = ctk.CTkFrame(params_scroll)
                param_frame.pack(fill="x", pady=5)
                
                # Risk level colors
                risk_color = "#55aa55"  # Low (green)
                if param_data.get("risk_level") == "high":
                    risk_color = "#ff5555"  # High (red)
                elif param_data.get("risk_level") == "medium":
                    risk_color = "#ffaa55"  # Medium (orange)
                
                # Parameter header
                header_frame = ctk.CTkFrame(param_frame, fg_color="#2b2b2b")
                header_frame.pack(fill="x", pady=0)
                
                param_name_label = ctk.CTkLabel(header_frame, text=param_name, font=("Arial", 12, "bold"))
                param_name_label.pack(side="left", padx=10, pady=5)
                
                risk_level = param_data.get("risk_level", "unknown").capitalize()
                risk_label = ctk.CTkLabel(header_frame, text=f"Risk: {risk_level}", 
                                        font=("Arial", 12, "bold"), text_color=risk_color)
                risk_label.pack(side="right", padx=10, pady=5)
                
                # Create details frame that starts collapsed
                details_frame = ctk.CTkFrame(param_frame)
                details_frame.pack(fill="x", pady=5, padx=10)
                details_frame.pack_forget()  # Initially hidden
                
                # Toggle button
                def toggle_details(f=details_frame, b=None):
                    if f.winfo_ismapped():
                        f.pack_forget()
                        if b:
                            b.configure(text="Show Details")
                    else:
                        f.pack(fill="x", pady=5, padx=10)
                        if b:
                            b.configure(text="Hide Details")
                
                toggle_button = ctk.CTkButton(param_frame, text="Show Details", 
                                           command=lambda f=details_frame, b=toggle_button: toggle_details(f, b))
                toggle_button.pack(anchor="w", pady=5, padx=10)
                
                # Parameter details
                details_text = f"Occurrences: {param_data.get('count', 0)}"
                details_label = ctk.CTkLabel(details_frame, text=details_text, font=("Arial", 12))
                details_label.pack(anchor="w", pady=2)
                
                # Risk factors
                if param_data.get("risk_factors"):
                    risk_factors_label = ctk.CTkLabel(details_frame, text="Risk Factors:", font=("Arial", 12, "bold"))
                    risk_factors_label.pack(anchor="w", pady=5)
                    
                    for factor in param_data.get("risk_factors", []):
                        factor_label = ctk.CTkLabel(details_frame, text=f"• {factor}", font=("Arial", 12))
                        factor_label.pack(anchor="w", padx=10)
                
                # Sources
                if param_data.get("sources"):
                    sources_label = ctk.CTkLabel(details_frame, text="Sources:", font=("Arial", 12, "bold"))
                    sources_label.pack(anchor="w", pady=5)
                    
                    sources_text = ", ".join(param_data.get("sources", []))
                    source_label = ctk.CTkLabel(details_frame, text=sources_text, font=("Arial", 12))
                    source_label.pack(anchor="w", padx=10)
                
                # Values preview
                if param_data.get("values"):
                    values_label = ctk.CTkLabel(details_frame, text="Sample Values:", font=("Arial", 12, "bold"))
                    values_label.pack(anchor="w", pady=5)
                    
                    for value in param_data.get("values", [])[:3]:  # Show up to 3 values
                        value_label = ctk.CTkLabel(details_frame, text=f"• {value}", font=("Arial", 12))
                        value_label.pack(anchor="w", padx=10)
                    
                    if len(param_data.get("values", [])) > 3:
                        more_label = ctk.CTkLabel(details_frame, 
                                               text=f"... and {len(param_data.get('values', [])) - 3} more", 
                                               font=("Arial", 12, "italic"))
                        more_label.pack(anchor="w", padx=10)
        
        # Create a frame for request list if there are any requests
        if self.processed_data.get("requests") and len(self.processed_data["requests"]) > 0:
            requests_frame = ctk.CTkFrame(self.processed_scroll)
            requests_frame.pack(fill="both", expand=True, pady=10, padx=10)
            
            requests_label = ctk.CTkLabel(requests_frame, text="Affected Requests", font=("Arial", 14, "bold"))
            requests_label.pack(anchor="w", pady=5, padx=10)
            
            # Create a scrollable frame for the requests
            requests_scroll = ctk.CTkScrollableFrame(requests_frame, height=200)
            requests_scroll.pack(fill="both", expand=True, pady=5, padx=10)
            
            # Create list header
            header_frame = ctk.CTkFrame(requests_scroll, fg_color="#1f538d")
            header_frame.pack(fill="x", pady=(0, 5))
            
            index_header = ctk.CTkLabel(header_frame, text="Index", font=("Arial", 12, "bold"), width=60)
            index_header.pack(side="left", padx=5, pady=5)
            
            method_header = ctk.CTkLabel(header_frame, text="Method", font=("Arial", 12, "bold"), width=80)
            method_header.pack(side="left", padx=5, pady=5)
            
            url_header = ctk.CTkLabel(header_frame, text="URL", font=("Arial", 12, "bold"), width=400)
            url_header.pack(side="left", padx=5, pady=5)
            
            params_header = ctk.CTkLabel(header_frame, text="Vulnerable Params", font=("Arial", 12, "bold"), width=100)
            params_header.pack(side="left", padx=5, pady=5)
            
            # Add items to the list
            for req in self.processed_data.get("requests", []):
                row_frame = ctk.CTkFrame(requests_scroll)
                row_frame.pack(fill="x", pady=1)
                
                index_label = ctk.CTkLabel(row_frame, text=str(req.get("index", "")), width=60)
                index_label.pack(side="left", padx=5, pady=5)
                
                method_label = ctk.CTkLabel(row_frame, text=req.get("method", "GET"), width=80)
                method_label.pack(side="left", padx=5, pady=5)
                
                url_label = ctk.CTkLabel(row_frame, text=req.get("url", ""), width=400, 
                                       anchor="w", wraplength=390)
                url_label.pack(side="left", padx=5, pady=5)
                
                params_label = ctk.CTkLabel(row_frame, text=str(req.get("vulnerable_param_count", 0)), width=100)
                params_label.pack(side="left", padx=5, pady=5)
                
                # Create details frame that starts collapsed
                details_frame = ctk.CTkFrame(requests_scroll)
                details_frame.pack(fill="x", pady=2, padx=20)
                details_frame.pack_forget()  # Initially hidden
                
                # Toggle button
                def toggle_details(f=details_frame, b=None, r=row_frame):
                    if f.winfo_ismapped():
                        f.pack_forget()
                        if b:
                            b.configure(text="➕")
                        if r:
                            r.configure(fg_color=("gray90", "gray10"))
                    else:
                        f.pack(fill="x", pady=2, padx=20, after=r)
                        if b:
                            b.configure(text="➖")
                        if r:
                            r.configure(fg_color=("gray80", "gray20"))
                
                details_button = ctk.CTkButton(row_frame, text="➕", width=30, height=20,
                                            command=lambda f=details_frame, b=None, r=row_frame: toggle_details(f, b, r))
                details_button.pack(side="right", padx=5)
                
                # Only add parameter details if there are parameters
                if req.get("parameters") and len(req.get("parameters", [])) > 0:
                    # Create a table for the parameters
                    param_table_frame = ctk.CTkFrame(details_frame)
                    param_table_frame.pack(fill="x", pady=5)
                    
                    # Add parameter headers
                    param_header_frame = ctk.CTkFrame(param_table_frame, fg_color="#1f538d")
                    param_header_frame.pack(fill="x", pady=0)
                    
                    param_name_header = ctk.CTkLabel(param_header_frame, text="Name", font=("Arial", 12, "bold"), width=120)
                    param_name_header.pack(side="left", padx=5, pady=2)
                    
                    param_source_header = ctk.CTkLabel(param_header_frame, text="Source", font=("Arial", 12, "bold"), width=80)
                    param_source_header.pack(side="left", padx=5, pady=2)
                    
                    param_value_header = ctk.CTkLabel(param_header_frame, text="Value", font=("Arial", 12, "bold"), width=200)
                    param_value_header.pack(side="left", padx=5, pady=2)
                    
                    param_risk_header = ctk.CTkLabel(param_header_frame, text="Risk", font=("Arial", 12, "bold"), width=80)
                    param_risk_header.pack(side="left", padx=5, pady=2)
                    
                    # Add parameter rows
                    for param in req.get("parameters", []):
                        param_row_frame = ctk.CTkFrame(param_table_frame)
                        param_row_frame.pack(fill="x", pady=1)
                        
                        # Risk level colors
                        risk_color = "#55aa55"  # Low (green)
                        if param.get("risk_level") == "high":
                            risk_color = "#ff5555"  # High (red)
                        elif param.get("risk_level") == "medium":
                            risk_color = "#ffaa55"  # Medium (orange)
                        
                        param_name_label = ctk.CTkLabel(param_row_frame, text=param.get("name", ""), 
                                                     width=120, anchor="w", wraplength=110)
                        param_name_label.pack(side="left", padx=5, pady=2)
                        
                        param_source_label = ctk.CTkLabel(param_row_frame, text=param.get("source", ""), 
                                                       width=80, anchor="w")
                        param_source_label.pack(side="left", padx=5, pady=2)
                        
                        param_value_label = ctk.CTkLabel(param_row_frame, text=param.get("value", ""), 
                                                      width=200, anchor="w", wraplength=190)
                        param_value_label.pack(side="left", padx=5, pady=2)
                        
                        risk_level = param.get("risk_level", "unknown").capitalize()
                        param_risk_label = ctk.CTkLabel(param_row_frame, text=risk_level, 
                                                     width=80, text_color=risk_color)
                        param_risk_label.pack(side="left", padx=5, pady=2)
    
    def render_url_parameters_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="URL Parameters Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Check if there are any URLs
        if not self.processed_data.get("urls") or len(self.processed_data["urls"]) == 0:
            no_data_label = ctk.CTkLabel(self.processed_scroll, text="No URLs found.", font=("Arial", 12))
            no_data_label.pack(pady=10)
            return
        
        # Display each URL
        for url_data in self.processed_data["urls"]:
            # Create a frame for this URL
            url_frame = ctk.CTkFrame(self.processed_scroll)
            url_frame.pack(fill="x", pady=5, padx=10)
            
            # URL header
            header_frame = ctk.CTkFrame(url_frame, fg_color="#2b2b2b")
            header_frame.pack(fill="x", pady=0)
            
            url_label = ctk.CTkLabel(header_frame, text=url_data.get("url", "Unknown"), font=("Arial", 12, "bold"),
                                   wraplength=600, justify="left")
            url_label.pack(side="left", padx=10, pady=5)
            
            method_label = ctk.CTkLabel(header_frame, text=f"{url_data.get('method', 'GET')} - {url_data.get('parameter_count', 0)} params", 
                                      font=("Arial", 12))
            method_label.pack(side="right", padx=10, pady=5)
            
            # Create details frame that starts collapsed
            details_frame = ctk.CTkFrame(url_frame)
            details_frame.pack(fill="x", pady=5, padx=10)
            details_frame.pack_forget()  # Initially hidden
            
            # Toggle button
            def toggle_details(f=details_frame, b=None):
                if f.winfo_ismapped():
                    f.pack_forget()
                    if b:
                        b.configure(text="Show Parameters")
                else:
                    f.pack(fill="x", pady=5, padx=10)
                    if b:
                        b.configure(text="Hide Parameters")
            
            toggle_button = ctk.CTkButton(url_frame, text="Show Parameters", command=lambda f=details_frame, b=toggle_button: toggle_details(f, b))
            toggle_button.pack(anchor="w", pady=5, padx=10)
            
            # Index info
            index_label = ctk.CTkLabel(details_frame, text=f"Index: {url_data.get('index', 'Unknown')}", font=("Arial", 12))
            index_label.pack(anchor="w", pady=5)
            
            # Parameters section
            if url_data.get("parameters"):
                params_label = ctk.CTkLabel(details_frame, text="Parameters:", font=("Arial", 12, "bold"))
                params_label.pack(anchor="w", pady=5)
                
                # Create table frame for parameters
                table_frame = ctk.CTkFrame(details_frame)
                table_frame.pack(fill="x", pady=5)
                
                # Table headers
                header_frame = ctk.CTkFrame(table_frame, fg_color="#1f538d")
                header_frame.pack(fill="x", pady=0)
                
                name_header = ctk.CTkLabel(header_frame, text="Name", font=("Arial", 12, "bold"), width=150)
                name_header.pack(side="left", padx=5, pady=5)
                
                value_header = ctk.CTkLabel(header_frame, text="Value", font=("Arial", 12, "bold"), width=400)
                value_header.pack(side="left", padx=5, pady=5)
                
                # Table rows
                for param in url_data.get("parameters", []):
                    row_frame = ctk.CTkFrame(table_frame)
                    row_frame.pack(fill="x", pady=2)
                    
                    name_cell = ctk.CTkLabel(row_frame, text=param.get("name", "Unknown"), width=150, 
                                          anchor="w", wraplength=140)
                    name_cell.pack(side="left", padx=5, pady=2)
                    
                    value_cell = ctk.CTkLabel(row_frame, text=param.get("value", ""), width=400, 
                                           anchor="w", wraplength=390)
                    value_cell.pack(side="left", padx=5, pady=2)
    
    def render_sql_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="SQL Injection Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display title and description if available
        if self.processed_data.get("title") or self.processed_data.get("description"):
            info_frame = ctk.CTkFrame(self.processed_scroll)
            info_frame.pack(fill="x", pady=5, padx=10)
            
            if self.processed_data.get("title"):
                title_label = ctk.CTkLabel(info_frame, text=f"Title: {self.processed_data.get('title')}", 
                                         font=("Arial", 14, "bold"))
                title_label.pack(anchor="w", pady=5, padx=10)
            
            if self.processed_data.get("description"):
                desc_label = ctk.CTkLabel(info_frame, text=f"Description: {self.processed_data.get('description')}", 
                                        font=("Arial", 12))
                desc_label.pack(anchor="w", pady=5, padx=10)
        
        # Display statistics
        stats_frame = ctk.CTkFrame(self.processed_scroll)
        stats_frame.pack(fill="x", pady=5, padx=10)
        
        stats_label = ctk.CTkLabel(stats_frame, text="Statistics", font=("Arial", 14, "bold"))
        stats_label.pack(anchor="w", pady=5, padx=10)
        
        stats_grid = ctk.CTkFrame(stats_frame)
        stats_grid.pack(fill="x", pady=5, padx=10)
        
        # Create a grid for stats (2x3)
        req_count_label = ctk.CTkLabel(stats_grid, 
                                     text=f"Total Requests: {self.processed_data.get('request_count', 0)}", 
                                     font=("Arial", 12))
        req_count_label.grid(row=0, column=0, sticky="w", padx=10, pady=2)
        
        vuln_req_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Requests with Vulnerable Params: {self.processed_data.get('requests_with_vulnerable_params', 0)}", 
                                    font=("Arial", 12))
        vuln_req_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
        
        total_vuln_label = ctk.CTkLabel(stats_grid, 
                                      text=f"Total Vulnerable Params: {self.processed_data.get('total_vulnerable_params', 0)}", 
                                      font=("Arial", 12))
        total_vuln_label.grid(row=0, column=2, sticky="w", padx=10, pady=2)
        
        high_risk_label = ctk.CTkLabel(stats_grid, 
                                     text=f"High Risk: {self.processed_data.get('high_risk_count', 0)}", 
                                     font=("Arial", 12), text_color="#ff5555")
        high_risk_label.grid(row=1, column=0, sticky="w", padx=10, pady=2)
        
        medium_risk_label = ctk.CTkLabel(stats_grid, 
                                       text=f"Medium Risk: {self.processed_data.get('medium_risk_count', 0)}", 
                                       font=("Arial", 12), text_color="#ffaa55")
        medium_risk_label.grid(row=1, column=1, sticky="w", padx=10, pady=2)
        
        low_risk_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Low Risk: {self.processed_data.get('low_risk_count', 0)}", 
                                    font=("Arial", 12), text_color="#55aa55")
        low_risk_label.grid(row=1, column=2, sticky="w", padx=10, pady=2)
        
        # Mind Map - Top Rectangle
        mind_map_frame = ctk.CTkFrame(self.processed_scroll, height=300)
        mind_map_frame.pack(fill="x", pady=10, padx=10)
        
        # Create canvas for mind map
        mind_map_canvas = tk.Canvas(mind_map_frame, height=300, bg="#2b2b2b", highlightthickness=0)
        mind_map_canvas.pack(fill="x", expand=True)
        
        # Set up mind map dimensions
        canvas_width = 800
        canvas_height = 300
        center_x = canvas_width // 2
        center_y = canvas_height // 2
        center_radius = 50
        param_radius = 40
        
        # Draw central circle
        mind_map_canvas.create_oval(
            center_x - center_radius, 
            center_y - center_radius, 
            center_x + center_radius, 
            center_y + center_radius, 
            fill="#1f538d", 
            outline="white"
        )
        
        # Add central text
        mind_map_canvas.create_text(
            center_x, 
            center_y, 
            text="Vulnerable\nParameters", 
            fill="white", 
            font=("Arial", 12, "bold"),
            justify="center"
        )
        
        # Get vulnerable parameters
        vulnerable_params = self.processed_data.get("vulnerable_parameters", {})
        
        # Calculate positions for parameter nodes
        num_params = len(vulnerable_params)
        if num_params > 0:
            # Calculate angle between each parameter
            angle_step = 2 * 3.14159 / num_params
            distance = 150  # Distance from center
            
            # Risk level colors
            risk_colors = {
                "High": "#ff5555",
                "Medium": "#ffaa55",
                "Low": "#55aa55"
            }
            
            # Draw each parameter node
            param_idx = 0
            for param_name, param_data in vulnerable_params.items():
                # Calculate position
                angle = param_idx * angle_step
                param_x = center_x + distance * math.cos(angle)
                param_y = center_y + distance * math.sin(angle)
                
                # Get risk level and color
                risk_level = param_data.get("risk_level", "Unknown")
                fill_color = risk_colors.get(risk_level, "#777777")
                
                # Draw line to parameter
                mind_map_canvas.create_line(
                    center_x, 
                    center_y, 
                    param_x, 
                    param_y, 
                    fill="white", 
                    width=2
                )
                
                # Draw parameter circle
                mind_map_canvas.create_oval(
                    param_x - param_radius, 
                    param_y - param_radius, 
                    param_x + param_radius, 
                    param_y + param_radius, 
                    fill=fill_color, 
                    outline="white"
                )
                
                # Add parameter name
                mind_map_canvas.create_text(
                    param_x, 
                    param_y, 
                    text=param_name, 
                    fill="white", 
                    font=("Arial", 12, "bold")
                )
                
                # Add parameter details
                details_text = f"Count: {param_data.get('count', 0)}\n{risk_level} Risk"
                mind_map_canvas.create_text(
                    param_x, 
                    param_y + param_radius + 15, 
                    text=details_text, 
                    fill="white", 
                    font=("Arial", 10),
                    justify="center"
                )
                
                param_idx += 1
        
        # Request List - Bottom Rectangle
        list_frame = ctk.CTkFrame(self.processed_scroll)
        list_frame.pack(fill="both", expand=True, pady=10, padx=10)
        
        # Create header for list
        list_header = ctk.CTkLabel(list_frame, text="Vulnerable Parameters by Request", font=("Arial", 14, "bold"))
        list_header.pack(anchor="w", pady=5, padx=10)
        
        # Create a scrollable frame for the list
        list_scroll = ctk.CTkScrollableFrame(list_frame, height=250)
        list_scroll.pack(fill="both", expand=True, pady=5, padx=10)
        
        # Create list header
        header_frame = ctk.CTkFrame(list_scroll, fg_color="#1f538d")
        header_frame.pack(fill="x", pady=(0, 5))
        
        index_header = ctk.CTkLabel(header_frame, text="Index", font=("Arial", 12, "bold"), width=60)
        index_header.pack(side="left", padx=5, pady=5)
        
        method_header = ctk.CTkLabel(header_frame, text="Method", font=("Arial", 12, "bold"), width=80)
        method_header.pack(side="left", padx=5, pady=5)
        
        url_header = ctk.CTkLabel(header_frame, text="URL", font=("Arial", 12, "bold"), width=300)
        url_header.pack(side="left", padx=5, pady=5)
        
        param_header = ctk.CTkLabel(header_frame, text="Parameter", font=("Arial", 12, "bold"), width=120)
        param_header.pack(side="left", padx=5, pady=5)
        
        value_header = ctk.CTkLabel(header_frame, text="Value", font=("Arial", 12, "bold"), width=120)
        value_header.pack(side="left", padx=5, pady=5)
        
        risk_header = ctk.CTkLabel(header_frame, text="Risk Level", font=("Arial", 12, "bold"), width=100)
        risk_header.pack(side="left", padx=5, pady=5)
        
        # Add items to the list
        if not self.processed_data.get("requests") or len(self.processed_data["requests"]) == 0:
            no_req_label = ctk.CTkLabel(list_scroll, text="No requests with vulnerable parameters found.", font=("Arial", 12))
            no_req_label.pack(pady=10)
        else:
            for req in self.processed_data.get("requests", []):
                # For each vulnerable parameter in a request, create a separate row
                for param in req.get("parameters", []):
                    row_frame = ctk.CTkFrame(list_scroll)
                    row_frame.pack(fill="x", pady=1)
                    
                    # Risk level colors
                    risk_color = "#55aa55"  # Low (green)
                    if param.get("risk_level") == "High":
                        risk_color = "#ff5555"  # High (red)
                    elif param.get("risk_level") == "Medium":
                        risk_color = "#ffaa55"  # Medium (orange)
                    
                    index_label = ctk.CTkLabel(row_frame, text=str(req.get("index", "")), width=60)
                    index_label.pack(side="left", padx=5, pady=5)
                    
                    method_label = ctk.CTkLabel(row_frame, text=req.get("method", "GET"), width=80)
                    method_label.pack(side="left", padx=5, pady=5)
                    
                    url_label = ctk.CTkLabel(row_frame, text=req.get("url", ""), width=300, 
                                           anchor="w", wraplength=290)
                    url_label.pack(side="left", padx=5, pady=5)
                    
                    param_label = ctk.CTkLabel(row_frame, text=param.get("name", ""), width=120, 
                                             anchor="w", wraplength=110)
                    param_label.pack(side="left", padx=5, pady=5)
                    
                    value_label = ctk.CTkLabel(row_frame, text=param.get("value", ""), width=120, 
                                             anchor="w", wraplength=110)
                    value_label.pack(side="left", padx=5, pady=5)
                    
                    risk_label = ctk.CTkLabel(row_frame, text=param.get("risk_level", "Unknown"), width=100, 
                                            text_color=risk_color, font=("Arial", 12, "bold"))
                    risk_label.pack(side="left", padx=5, pady=5)
    
    def render_sensitive_info_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="Sensitive Information Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Check if there are any URLs
        if not self.processed_data.get("urls") or len(self.processed_data["urls"]) == 0:
            no_data_label = ctk.CTkLabel(self.processed_scroll, text="No URLs with sensitive information found.", font=("Arial", 12))
            no_data_label.pack(pady=10)
            return
        
        # Display each URL
        for url_data in self.processed_data["urls"]:
            # Create a frame for this URL
            url_frame = ctk.CTkFrame(self.processed_scroll)
            url_frame.pack(fill="x", pady=5, padx=10)
            
            # URL header
            header_frame = ctk.CTkFrame(url_frame, fg_color="#2b2b2b")
            header_frame.pack(fill="x", pady=0)
            
            url_label = ctk.CTkLabel(header_frame, text=url_data.get("url", "Unknown"), font=("Arial", 12, "bold"),
                                   wraplength=600, justify="left")
            url_label.pack(padx=10, pady=5)
            
            # Create details frame that starts collapsed
            details_frame = ctk.CTkFrame(url_frame)
            details_frame.pack(fill="x", pady=5, padx=10)
            details_frame.pack_forget()  # Initially hidden
            
            # Toggle button
            def toggle_details(f=details_frame, b=None):
                if f.winfo_ismapped():
                    f.pack_forget()
                    if b:
                        b.configure(text="Show Findings")
                else:
                    f.pack(fill="x", pady=5, padx=10)
                    if b:
                        b.configure(text="Hide Findings")
            
            toggle_button = ctk.CTkButton(url_frame, text="Show Findings", 
                                       command=lambda f=details_frame, b=toggle_button: toggle_details(f, b))
            toggle_button.pack(anchor="w", pady=5, padx=10)
            
            # Findings section
            if url_data.get("findings"):
                findings_label = ctk.CTkLabel(details_frame, text="Findings:", font=("Arial", 12, "bold"))
                findings_label.pack(anchor="w", pady=5)
                
                for finding in url_data.get("findings", []):
                    finding_frame = ctk.CTkFrame(details_frame)
                    finding_frame.pack(fill="x", pady=2)
                    
                    finding_label = ctk.CTkLabel(finding_frame, text=f"• {finding}", font=("Arial", 12),
                                             wraplength=600, justify="left")
                    finding_label.pack(anchor="w", padx=10, pady=2)
    
    def render_path_finder_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="Path Finder Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display stats section
        stats_frame = ctk.CTkFrame(self.processed_scroll)
        stats_frame.pack(fill="x", pady=5, padx=10)
        
        # URL info
        url_frame = ctk.CTkFrame(stats_frame)
        url_frame.pack(fill="x", pady=5, padx=5)
        
        url_label = ctk.CTkLabel(url_frame, text=f"Target URL: {self.processed_data.get('url', 'Unknown')}", 
                               font=("Arial", 12, "bold"))
        url_label.pack(anchor="w", pady=2, padx=5)
        
        if self.processed_data.get("base_url"):
            base_url_label = ctk.CTkLabel(url_frame, text=f"Base URL: {self.processed_data.get('base_url')}", 
                                        font=("Arial", 12))
            base_url_label.pack(anchor="w", pady=2, padx=5)
        
        # Stats info
        if self.processed_data.get("stats"):
            stats_header = ctk.CTkLabel(stats_frame, text="Statistics:", font=("Arial", 14, "bold"))
            stats_header.pack(anchor="w", pady=5, padx=5)
            
            stats_grid = ctk.CTkFrame(stats_frame)
            stats_grid.pack(fill="x", pady=5, padx=5)
            
            # Create a grid for stats (2x2)
            stats = self.processed_data.get("stats", {})
            
            # Row 1
            total_paths_label = ctk.CTkLabel(stats_grid, text=f"Total Paths: {stats.get('total_paths', 0)}", 
                                           font=("Arial", 12))
            total_paths_label.grid(row=0, column=0, sticky="w", padx=10, pady=2)
            
            total_dirs_label = ctk.CTkLabel(stats_grid, text=f"Total Directories: {stats.get('total_directories', 0)}", 
                                          font=("Arial", 12))
            total_dirs_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
            
            # Row 2
            total_files_label = ctk.CTkLabel(stats_grid, text=f"Total Files: {stats.get('total_files', 0)}", 
                                           font=("Arial", 12))
            total_files_label.grid(row=1, column=0, sticky="w", padx=10, pady=2)
            
            interesting_ext_label = ctk.CTkLabel(stats_grid, text=f"Interesting Extensions: {stats.get('interesting_extensions', 0)}", 
                                              font=("Arial", 12))
            interesting_ext_label.grid(row=1, column=1, sticky="w", padx=10, pady=2)
        
        # Source info
        if self.processed_data.get("aggregate_source_count") or self.processed_data.get("source_urls"):
            source_label = ctk.CTkLabel(stats_frame, text=f"Sources: {self.processed_data.get('aggregate_source_count', 0)} URLs", 
                                      font=("Arial", 12))
            source_label.pack(anchor="w", pady=5, padx=5)
        
        # Create button frame
        button_frame = ctk.CTkFrame(self.processed_scroll)
        button_frame.pack(fill="x", pady=10, padx=10)
        
        # Create a frame to hold the content that will change based on button clicks
        self.path_content_frame = ctk.CTkFrame(self.processed_scroll)
        self.path_content_frame.pack(fill="both", expand=True, pady=5, padx=10)
        
        # Function to update content based on button click
        def show_content(content_type):
            # Clear current content
            for widget in self.path_content_frame.winfo_children():
                widget.destroy()
            
            if content_type == "findings":
                # Create a scrollable frame for findings
                findings_frame = ctk.CTkScrollableFrame(self.path_content_frame, height=300)
                findings_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Add header for findings
                header_frame = ctk.CTkFrame(findings_frame, fg_color="#1f538d")
                header_frame.pack(fill="x", pady=(0, 5))
                
                check_url_header = ctk.CTkLabel(header_frame, text="Check URL", font=("Arial", 12, "bold"), width=300)
                check_url_header.pack(side="left", padx=5, pady=5)
                
                path_header = ctk.CTkLabel(header_frame, text="Path", font=("Arial", 12, "bold"), width=200)
                path_header.pack(side="left", padx=5, pady=5)
                
                type_header = ctk.CTkLabel(header_frame, text="Type", font=("Arial", 12, "bold"), width=100)
                type_header.pack(side="left", padx=5, pady=5)
                
                # Add findings data
                if not self.processed_data.get("findings") or len(self.processed_data["findings"]) == 0:
                    no_findings_label = ctk.CTkLabel(findings_frame, text="No findings available.", font=("Arial", 12))
                    no_findings_label.pack(pady=10)
                else:
                    for finding in self.processed_data.get("findings", []):
                        finding_frame = ctk.CTkFrame(findings_frame)
                        finding_frame.pack(fill="x", pady=1)
                        
                        # Determine color based on confirmed status
                        text_color = "#00cc00" if finding.get("confirmed", 0) == 1 else "white"
                        
                        check_url_label = ctk.CTkLabel(finding_frame, text=finding.get("check_url", ""), 
                                                    width=300, anchor="w", wraplength=290, text_color=text_color)
                        check_url_label.pack(side="left", padx=5, pady=5)
                        
                        path_label = ctk.CTkLabel(finding_frame, text=finding.get("path", ""), 
                                               width=200, anchor="w", wraplength=190, text_color=text_color)
                        path_label.pack(side="left", padx=5, pady=5)
                        
                        type_label = ctk.CTkLabel(finding_frame, text=finding.get("type", ""), 
                                               width=100, anchor="w", text_color=text_color)
                        type_label.pack(side="left", padx=5, pady=5)
                        
            elif content_type == "directories":
                # Create a scrollable frame for directories
                directories_frame = ctk.CTkScrollableFrame(self.path_content_frame, height=300)
                directories_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Add directories data
                if not self.processed_data.get("directories") or len(self.processed_data["directories"]) == 0:
                    no_dirs_label = ctk.CTkLabel(directories_frame, text="No directories found.", font=("Arial", 12))
                    no_dirs_label.pack(pady=10)
                else:
                    for directory in self.processed_data.get("directories", []):
                        dir_frame = ctk.CTkFrame(directories_frame)
                        dir_frame.pack(fill="x", pady=1)
                        
                        dir_label = ctk.CTkLabel(dir_frame, text=directory, font=("Arial", 12),
                                              wraplength=600, justify="left")
                        dir_label.pack(anchor="w", padx=10, pady=5)
            
            elif content_type == "paths":
                # Create a scrollable frame for paths
                paths_frame = ctk.CTkScrollableFrame(self.path_content_frame, height=300)
                paths_frame.pack(fill="both", expand=True, padx=5, pady=5)
                
                # Add paths data
                if not self.processed_data.get("paths") or len(self.processed_data["paths"]) == 0:
                    no_paths_label = ctk.CTkLabel(paths_frame, text="No paths found.", font=("Arial", 12))
                    no_paths_label.pack(pady=10)
                else:
                    for path in self.processed_data.get("paths", []):
                        path_frame = ctk.CTkFrame(paths_frame)
                        path_frame.pack(fill="x", pady=1)
                        
                        path_label = ctk.CTkLabel(path_frame, text=path, font=("Arial", 12),
                                               wraplength=600, justify="left")
                        path_label.pack(anchor="w", padx=10, pady=5)
        
        # Create buttons
        findings_button = ctk.CTkButton(button_frame, text="Findings", 
                                      command=lambda: show_content("findings"))
        findings_button.pack(side="left", padx=10, pady=10)
        
        directories_button = ctk.CTkButton(button_frame, text="Directories", 
                                         command=lambda: show_content("directories"))
        directories_button.pack(side="left", padx=10, pady=10)
        
        paths_button = ctk.CTkButton(button_frame, text="Paths", 
                                   command=lambda: show_content("paths"))
        paths_button.pack(side="left", padx=10, pady=10)
        
        # Show findings by default
        show_content("findings")
    
    def render_json_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="JSON Analysis Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display summary information if available
        if self.processed_data.get("title") or self.processed_data.get("description"):
            summary_frame = ctk.CTkFrame(self.processed_scroll)
            summary_frame.pack(fill="x", pady=5, padx=10)
            
            if self.processed_data.get("title"):
                title_label = ctk.CTkLabel(summary_frame, text=f"Title: {self.processed_data.get('title')}", 
                                         font=("Arial", 14, "bold"))
                title_label.pack(anchor="w", pady=5, padx=10)
            
            if self.processed_data.get("description"):
                desc_label = ctk.CTkLabel(summary_frame, text=f"Description: {self.processed_data.get('description')}", 
                                        font=("Arial", 12))
                desc_label.pack(anchor="w", pady=5, padx=10)
            
            counts_frame = ctk.CTkFrame(summary_frame)
            counts_frame.pack(fill="x", pady=5, padx=10)
            
            request_count_label = ctk.CTkLabel(counts_frame, 
                                             text=f"Total Requests: {self.processed_data.get('request_count', 0)}",
                                             font=("Arial", 12))
            request_count_label.pack(side="left", padx=10)
            
            json_count_label = ctk.CTkLabel(counts_frame, 
                                          text=f"JSON Requests: {self.processed_data.get('json_request_count', 0)}",
                                          font=("Arial", 12))
            json_count_label.pack(side="left", padx=10)
            
            param_count_label = ctk.CTkLabel(counts_frame, 
                                           text=f"Total Parameters: {self.processed_data.get('total_parameters', 0)}",
                                           font=("Arial", 12))
            param_count_label.pack(side="left", padx=10)
        
        # Create list header frame
        list_header_frame = ctk.CTkFrame(self.processed_scroll, fg_color="#1f538d")
        list_header_frame.pack(fill="x", pady=(10, 0), padx=10)
        
        index_header = ctk.CTkLabel(list_header_frame, text="Index", font=("Arial", 12, "bold"), width=80)
        index_header.pack(side="left", padx=5, pady=5)
        
        url_header = ctk.CTkLabel(list_header_frame, text="URL", font=("Arial", 12, "bold"), width=500)
        url_header.pack(side="left", padx=5, pady=5)
        
        size_header = ctk.CTkLabel(list_header_frame, text="Size (bytes)", font=("Arial", 12, "bold"), width=100)
        size_header.pack(side="left", padx=5, pady=5)
        
        # Check if there are any debug_info entries
        if not self.processed_data.get("debug_info") or len(self.processed_data["debug_info"]) == 0:
            no_data_label = ctk.CTkLabel(self.processed_scroll, text="No request data found.", font=("Arial", 12))
            no_data_label.pack(pady=10)
            return
        
        # List container frame
        list_frame = ctk.CTkFrame(self.processed_scroll)
        list_frame.pack(fill="x", expand=True, pady=0, padx=10)
        
        # Display each debug_info entry in a list format
        for entry in self.processed_data["debug_info"]:
            entry_frame = ctk.CTkFrame(list_frame)
            entry_frame.pack(fill="x", pady=1)
            
            index_label = ctk.CTkLabel(entry_frame, text=str(entry.get("index", "N/A")), width=80, anchor="w")
            index_label.pack(side="left", padx=5, pady=5)
            
            url_label = ctk.CTkLabel(entry_frame, text=entry.get("url", "Unknown"), width=500, 
                                   anchor="w", wraplength=490)
            url_label.pack(side="left", padx=5, pady=5)
            
            size_label = ctk.CTkLabel(entry_frame, text=str(entry.get("body_length", 0)), width=100, anchor="e")
            size_label.pack(side="left", padx=5, pady=5)
    
    def render_default_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text=f"Results for {self.current_test_type}", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display the data in a simple format
        data_text = ctk.CTkTextbox(self.processed_scroll, height=400, width=800)
        data_text.pack(fill="both", expand=True, pady=10, padx=10)
        data_text.insert("1.0", json.dumps(self.processed_data, indent=2))
        data_text.configure(state="disabled")  # Make read-only

    def render_css_results(self):
        # Create header
        header_label = ctk.CTkLabel(self.processed_scroll, text="CSS Injection Results", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Display title and description if available
        if self.processed_data.get("title") or self.processed_data.get("description"):
            info_frame = ctk.CTkFrame(self.processed_scroll)
            info_frame.pack(fill="x", pady=5, padx=10)
            
            if self.processed_data.get("title"):
                title_label = ctk.CTkLabel(info_frame, text=f"Title: {self.processed_data.get('title')}", 
                                         font=("Arial", 14, "bold"))
                title_label.pack(anchor="w", pady=5, padx=10)
            
            if self.processed_data.get("description"):
                desc_label = ctk.CTkLabel(info_frame, text=f"Description: {self.processed_data.get('description')}", 
                                        font=("Arial", 12))
                desc_label.pack(anchor="w", pady=5, padx=10)
        
        # Display statistics
        stats_frame = ctk.CTkFrame(self.processed_scroll)
        stats_frame.pack(fill="x", pady=5, padx=10)
        
        stats_label = ctk.CTkLabel(stats_frame, text="Statistics", font=("Arial", 14, "bold"))
        stats_label.pack(anchor="w", pady=5, padx=10)
        
        stats_grid = ctk.CTkFrame(stats_frame)
        stats_grid.pack(fill="x", pady=5, padx=10)
        
        # Create a grid for stats (2x3)
        req_count_label = ctk.CTkLabel(stats_grid, 
                                     text=f"Total Requests: {self.processed_data.get('request_count', 0)}", 
                                     font=("Arial", 12))
        req_count_label.grid(row=0, column=0, sticky="w", padx=10, pady=2)
        
        vuln_req_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Requests with Vulnerable Params: {self.processed_data.get('requests_with_vulnerable_params', 0)}", 
                                    font=("Arial", 12))
        vuln_req_label.grid(row=0, column=1, sticky="w", padx=10, pady=2)
        
        total_vuln_label = ctk.CTkLabel(stats_grid, 
                                      text=f"Total Vulnerable Params: {self.processed_data.get('total_vulnerable_params', 0)}", 
                                      font=("Arial", 12))
        total_vuln_label.grid(row=0, column=2, sticky="w", padx=10, pady=2)
        
        # Risk level counts with appropriate colors
        high_risk_label = ctk.CTkLabel(stats_grid, 
                                     text=f"High Risk: {self.processed_data.get('high_risk_count', 0)}", 
                                     font=("Arial", 12), text_color="#ff5555")
        high_risk_label.grid(row=1, column=0, sticky="w", padx=10, pady=2)
        
        medium_risk_label = ctk.CTkLabel(stats_grid, 
                                       text=f"Medium Risk: {self.processed_data.get('medium_risk_count', 0)}", 
                                       font=("Arial", 12), text_color="#ffaa55")
        medium_risk_label.grid(row=1, column=1, sticky="w", padx=10, pady=2)
        
        low_risk_label = ctk.CTkLabel(stats_grid, 
                                    text=f"Low Risk: {self.processed_data.get('low_risk_count', 0)}", 
                                    font=("Arial", 12), text_color="#55aa55")
        low_risk_label.grid(row=1, column=2, sticky="w", padx=10, pady=2)
        
        # Check if there are any results
        if not self.processed_data.get("vulnerable_parameters") or len(self.processed_data["vulnerable_parameters"]) == 0:
            if not self.processed_data.get("requests") or len(self.processed_data["requests"]) == 0:
                no_data_label = ctk.CTkLabel(self.processed_scroll, text="No vulnerable CSS parameters found.", font=("Arial", 12))
                no_data_label.pack(pady=10)
                return
        
        # Create tabbed interface for two different views
        tab_view = ctk.CTkTabview(self.processed_scroll)
        tab_view.pack(fill="both", expand=True, pady=10, padx=10)
        
        # Create tabs
        param_tab = tab_view.add("Parameters")
        req_tab = tab_view.add("Requests")
        
        # PARAMETERS TAB - CSS Parameters with visual representation
        if self.processed_data.get("vulnerable_parameters") and len(self.processed_data["vulnerable_parameters"]) > 0:
            # Create scrollable frame for parameters
            param_scroll = ctk.CTkScrollableFrame(param_tab)
            param_scroll.pack(fill="both", expand=True, pady=5, padx=5)
            
            # Create visual representation of parameters - CSS specific styling
            for param_name, param_data in self.processed_data["vulnerable_parameters"].items():
                # Create a frame for this parameter with styling
                param_frame = ctk.CTkFrame(param_scroll)
                param_frame.pack(fill="x", pady=5, padx=5)
                
                # Risk level colors
                risk_color = "#55aa55"  # Low (green)
                if param_data.get("risk_level") == "high":
                    risk_color = "#ff5555"  # High (red)
                elif param_data.get("risk_level") == "medium":
                    risk_color = "#ffaa55"  # Medium (orange)
                
                # CSS-specific styling based on parameter name
                header_bg = "#2b2b2b"
                if any(css_term in param_name.lower() for css_term in ["color", "background", "style", "css"]):
                    header_bg = "#1f3b5c"  # Bluish for style-related
                elif any(css_term in param_name.lower() for css_term in ["font", "text", "typography"]):
                    header_bg = "#3b2d4c"  # Purplish for font-related
                elif any(css_term in param_name.lower() for css_term in ["layout", "margin", "padding", "border"]):
                    header_bg = "#2d4c2d"  # Greenish for layout-related
                
                # Parameter header with custom styling
                header_frame = ctk.CTkFrame(param_frame, fg_color=header_bg)
                header_frame.pack(fill="x", pady=0)
                
                param_name_label = ctk.CTkLabel(header_frame, text=param_name, font=("Arial", 12, "bold"))
                param_name_label.pack(side="left", padx=10, pady=5)
                
                risk_level = param_data.get("risk_level", "unknown").capitalize()
                risk_label = ctk.CTkLabel(header_frame, text=f"Risk: {risk_level}", 
                                        font=("Arial", 12, "bold"), text_color=risk_color)
                risk_label.pack(side="right", padx=10, pady=5)
                
                # Create details frame that starts collapsed
                details_frame = ctk.CTkFrame(param_frame)
                details_frame.pack(fill="x", pady=5, padx=10)
                details_frame.pack_forget()  # Initially hidden
                
                # Toggle button
                def toggle_details(f=details_frame, b=None):
                    if f.winfo_ismapped():
                        f.pack_forget()
                        if b:
                            b.configure(text="Show Details")
                    else:
                        f.pack(fill="x", pady=5, padx=10)
                        if b:
                            b.configure(text="Hide Details")
                
                toggle_button = ctk.CTkButton(param_frame, text="Show Details", 
                                           command=lambda f=details_frame, b=toggle_button: toggle_details(f, b))
                toggle_button.pack(anchor="w", pady=5, padx=10)
                
                # Parameter details
                details_text = f"Occurrences: {param_data.get('count', 0)}"
                details_label = ctk.CTkLabel(details_frame, text=details_text, font=("Arial", 12))
                details_label.pack(anchor="w", pady=2)
                
                # Risk factors
                if param_data.get("risk_factors"):
                    risk_factors_label = ctk.CTkLabel(details_frame, text="Risk Factors:", font=("Arial", 12, "bold"))
                    risk_factors_label.pack(anchor="w", pady=5)
                    
                    for factor in param_data.get("risk_factors", []):
                        factor_label = ctk.CTkLabel(details_frame, text=f"• {factor}", font=("Arial", 12))
                        factor_label.pack(anchor="w", padx=10)
                
                # Sources
                if param_data.get("sources"):
                    sources_label = ctk.CTkLabel(details_frame, text="Sources:", font=("Arial", 12, "bold"))
                    sources_label.pack(anchor="w", pady=5)
                    
                    sources_text = ", ".join(param_data.get("sources", []))
                    source_label = ctk.CTkLabel(details_frame, text=sources_text, font=("Arial", 12))
                    source_label.pack(anchor="w", padx=10)
                
                # Values preview
                if param_data.get("values"):
                    values_label = ctk.CTkLabel(details_frame, text="Sample Values:", font=("Arial", 12, "bold"))
                    values_label.pack(anchor="w", pady=5)
                    
                    # Create a special presentation for CSS values
                    for value in param_data.get("values", [])[:3]:  # Show up to 3 values
                        value_frame = ctk.CTkFrame(details_frame)
                        value_frame.pack(fill="x", pady=2, padx=10)
                        
                        value_label = ctk.CTkLabel(value_frame, text=value, font=("Arial", 12))
                        value_label.pack(anchor="w", pady=2)
                    
                    if len(param_data.get("values", [])) > 3:
                        more_label = ctk.CTkLabel(details_frame, 
                                               text=f"... and {len(param_data.get('values', [])) - 3} more", 
                                               font=("Arial", 12, "italic"))
                        more_label.pack(anchor="w", padx=10)
        else:
            no_params_label = ctk.CTkLabel(param_tab, text="No vulnerable CSS parameters found.", font=("Arial", 12))
            no_params_label.pack(pady=10)
        
        # REQUESTS TAB - Tabular list of affected requests
        if self.processed_data.get("requests") and len(self.processed_data["requests"]) > 0:
            # Create scrollable frame for requests
            req_scroll = ctk.CTkScrollableFrame(req_tab)
            req_scroll.pack(fill="both", expand=True, pady=5, padx=5)
            
            # Create list header
            header_frame = ctk.CTkFrame(req_scroll, fg_color="#1f538d")
            header_frame.pack(fill="x", pady=(0, 5))
            
            index_header = ctk.CTkLabel(header_frame, text="Index", font=("Arial", 12, "bold"), width=60)
            index_header.pack(side="left", padx=5, pady=5)
            
            method_header = ctk.CTkLabel(header_frame, text="Method", font=("Arial", 12, "bold"), width=80)
            method_header.pack(side="left", padx=5, pady=5)
            
            url_header = ctk.CTkLabel(header_frame, text="URL", font=("Arial", 12, "bold"), width=400)
            url_header.pack(side="left", padx=5, pady=5)
            
            params_header = ctk.CTkLabel(header_frame, text="Vulnerable Params", font=("Arial", 12, "bold"), width=100)
            params_header.pack(side="left", padx=5, pady=5)
            
            # Add items to the list
            for req in self.processed_data.get("requests", []):
                row_frame = ctk.CTkFrame(req_scroll)
                row_frame.pack(fill="x", pady=1)
                
                index_label = ctk.CTkLabel(row_frame, text=str(req.get("index", "")), width=60)
                index_label.pack(side="left", padx=5, pady=5)
                
                method_label = ctk.CTkLabel(row_frame, text=req.get("method", "GET"), width=80)
                method_label.pack(side="left", padx=5, pady=5)
                
                url_label = ctk.CTkLabel(row_frame, text=req.get("url", ""), width=400, 
                                       anchor="w", wraplength=390)
                url_label.pack(side="left", padx=5, pady=5)
                
                params_label = ctk.CTkLabel(row_frame, text=str(req.get("vulnerable_param_count", 0)), width=100)
                params_label.pack(side="left", padx=5, pady=5)
                
                # Create details frame that starts collapsed
                details_frame = ctk.CTkFrame(req_scroll)
                details_frame.pack(fill="x", pady=2, padx=20)
                details_frame.pack_forget()  # Initially hidden
                
                # Toggle button
                def toggle_details(f=details_frame, b=None, r=row_frame):
                    if f.winfo_ismapped():
                        f.pack_forget()
                        if b:
                            b.configure(text="➕")
                        if r:
                            r.configure(fg_color=("gray90", "gray10"))
                    else:
                        f.pack(fill="x", pady=2, padx=20, after=r)
                        if b:
                            b.configure(text="➖")
                        if r:
                            r.configure(fg_color=("gray80", "gray20"))
                
                details_button = ctk.CTkButton(row_frame, text="➕", width=30, height=20,
                                            command=lambda f=details_frame, b=None, r=row_frame: toggle_details(f, b, r))
                details_button.pack(side="right", padx=5)
                
                # Only add parameter details if there are parameters
                if req.get("parameters") and len(req.get("parameters", [])) > 0:
                    # Create a table for the parameters
                    param_table_frame = ctk.CTkFrame(details_frame)
                    param_table_frame.pack(fill="x", pady=5)
                    
                    # Add parameter headers
                    param_header_frame = ctk.CTkFrame(param_table_frame, fg_color="#1f538d")
                    param_header_frame.pack(fill="x", pady=0)
                    
                    param_name_header = ctk.CTkLabel(param_header_frame, text="Name", font=("Arial", 12, "bold"), width=120)
                    param_name_header.pack(side="left", padx=5, pady=2)
                    
                    param_source_header = ctk.CTkLabel(param_header_frame, text="Source", font=("Arial", 12, "bold"), width=80)
                    param_source_header.pack(side="left", padx=5, pady=2)
                    
                    param_value_header = ctk.CTkLabel(param_header_frame, text="Value", font=("Arial", 12, "bold"), width=200)
                    param_value_header.pack(side="left", padx=5, pady=2)
                    
                    param_risk_header = ctk.CTkLabel(param_header_frame, text="Risk", font=("Arial", 12, "bold"), width=80)
                    param_risk_header.pack(side="left", padx=5, pady=2)
                    
                    # Add parameter rows
                    for param in req.get("parameters", []):
                        param_row_frame = ctk.CTkFrame(param_table_frame)
                        param_row_frame.pack(fill="x", pady=1)
                        
                        # Risk level colors
                        risk_color = "#55aa55"  # Low (green)
                        if param.get("risk_level") == "high":
                            risk_color = "#ff5555"  # High (red)
                        elif param.get("risk_level") == "medium":
                            risk_color = "#ffaa55"  # Medium (orange)
                        
                        param_name_label = ctk.CTkLabel(param_row_frame, text=param.get("name", ""), 
                                                     width=120, anchor="w", wraplength=110)
                        param_name_label.pack(side="left", padx=5, pady=2)
                        
                        param_source_label = ctk.CTkLabel(param_row_frame, text=param.get("source", ""), 
                                                       width=80, anchor="w")
                        param_source_label.pack(side="left", padx=5, pady=2)
                        
                        param_value_label = ctk.CTkLabel(param_row_frame, text=param.get("value", ""), 
                                                      width=200, anchor="w", wraplength=190)
                        param_value_label.pack(side="left", padx=5, pady=2)
                        
                        risk_level = param.get("risk_level", "unknown").capitalize()
                        param_risk_label = ctk.CTkLabel(param_row_frame, text=risk_level, 
                                                     width=80, text_color=risk_color)
                        param_risk_label.pack(side="left", padx=5, pady=2)
        else:
            no_reqs_label = ctk.CTkLabel(req_tab, text="No requests with vulnerable CSS parameters found.", font=("Arial", 12))
            no_reqs_label.pack(pady=10)

def main():
    parser = argparse.ArgumentParser(description='Security Testing Directory Navigator (Offline GUI)')
    parser.add_argument('--dir', type=str, required=True, help='Base directory containing test results')
    
    args = parser.parse_args()
    
    if not os.path.isdir(args.dir):
        print(f"Error: Directory '{args.dir}' does not exist or is not a directory.")
        return
    
    root = ctk.CTk()
    app = NavigatorApp(root, args.dir)
    root.mainloop()

# To this corrected code:
if __name__ == "__main__":
    main()
